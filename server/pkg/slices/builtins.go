// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package slices

import (
	uuid2 "github.com/satori/go.uuid"
)

type BoolSlice []bool
type BoolSlicePtrs []*bool

var (
	_ uuid2.UUID
)

func (slice BoolSlice) UniqueBy(keyer func(bool) interface{}) BoolSlice {
	u := map[interface{}]bool{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []bool{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice BoolSlice) FilterBy(predicate func(bool) bool) BoolSlice {
	out := []bool{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice BoolSlice) Contains(t bool) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice BoolSlice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice BoolSlice) SameAs(other BoolSlice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[bool]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice BoolSlicePtrs) UniqueBy(keyer func(*bool) interface{}) BoolSlicePtrs {
	u := map[interface{}]*bool{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*bool{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice BoolSlicePtrs) FilterBy(predicate func(*bool) bool) BoolSlicePtrs {
	out := []*bool{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice BoolSlicePtrs) Contains(t *bool) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice BoolSlicePtrs) FilterNotNil() BoolSlicePtrs {
	return slice.FilterBy(func(t *bool) bool {
		return t != nil
	})
}

func (slice BoolSlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice BoolSlicePtrs) SameAs(other BoolSlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*bool]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type ByteSlice []byte
type ByteSlicePtrs []*byte

var (
	_ uuid2.UUID
)

func (slice ByteSlice) UniqueBy(keyer func(byte) interface{}) ByteSlice {
	u := map[interface{}]byte{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []byte{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice ByteSlice) FilterBy(predicate func(byte) bool) ByteSlice {
	out := []byte{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice ByteSlice) Contains(t byte) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice ByteSlice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice ByteSlice) SameAs(other ByteSlice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[byte]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice ByteSlicePtrs) UniqueBy(keyer func(*byte) interface{}) ByteSlicePtrs {
	u := map[interface{}]*byte{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*byte{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice ByteSlicePtrs) FilterBy(predicate func(*byte) bool) ByteSlicePtrs {
	out := []*byte{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice ByteSlicePtrs) Contains(t *byte) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice ByteSlicePtrs) FilterNotNil() ByteSlicePtrs {
	return slice.FilterBy(func(t *byte) bool {
		return t != nil
	})
}

func (slice ByteSlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice ByteSlicePtrs) SameAs(other ByteSlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*byte]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type Complex128Slice []complex128
type Complex128SlicePtrs []*complex128

var (
	_ uuid2.UUID
)

func (slice Complex128Slice) UniqueBy(keyer func(complex128) interface{}) Complex128Slice {
	u := map[interface{}]complex128{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []complex128{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Complex128Slice) FilterBy(predicate func(complex128) bool) Complex128Slice {
	out := []complex128{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Complex128Slice) Contains(t complex128) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Complex128Slice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Complex128Slice) SameAs(other Complex128Slice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[complex128]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice Complex128SlicePtrs) UniqueBy(keyer func(*complex128) interface{}) Complex128SlicePtrs {
	u := map[interface{}]*complex128{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*complex128{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Complex128SlicePtrs) FilterBy(predicate func(*complex128) bool) Complex128SlicePtrs {
	out := []*complex128{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Complex128SlicePtrs) Contains(t *complex128) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Complex128SlicePtrs) FilterNotNil() Complex128SlicePtrs {
	return slice.FilterBy(func(t *complex128) bool {
		return t != nil
	})
}

func (slice Complex128SlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Complex128SlicePtrs) SameAs(other Complex128SlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*complex128]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type Complex64Slice []complex64
type Complex64SlicePtrs []*complex64

var (
	_ uuid2.UUID
)

func (slice Complex64Slice) UniqueBy(keyer func(complex64) interface{}) Complex64Slice {
	u := map[interface{}]complex64{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []complex64{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Complex64Slice) FilterBy(predicate func(complex64) bool) Complex64Slice {
	out := []complex64{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Complex64Slice) Contains(t complex64) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Complex64Slice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Complex64Slice) SameAs(other Complex64Slice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[complex64]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice Complex64SlicePtrs) UniqueBy(keyer func(*complex64) interface{}) Complex64SlicePtrs {
	u := map[interface{}]*complex64{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*complex64{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Complex64SlicePtrs) FilterBy(predicate func(*complex64) bool) Complex64SlicePtrs {
	out := []*complex64{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Complex64SlicePtrs) Contains(t *complex64) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Complex64SlicePtrs) FilterNotNil() Complex64SlicePtrs {
	return slice.FilterBy(func(t *complex64) bool {
		return t != nil
	})
}

func (slice Complex64SlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Complex64SlicePtrs) SameAs(other Complex64SlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*complex64]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type ErrorSlice []error
type ErrorSlicePtrs []*error

var (
	_ uuid2.UUID
)

func (slice ErrorSlice) UniqueBy(keyer func(error) interface{}) ErrorSlice {
	u := map[interface{}]error{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []error{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice ErrorSlice) FilterBy(predicate func(error) bool) ErrorSlice {
	out := []error{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice ErrorSlice) Contains(t error) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice ErrorSlice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice ErrorSlice) SameAs(other ErrorSlice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[error]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice ErrorSlicePtrs) UniqueBy(keyer func(*error) interface{}) ErrorSlicePtrs {
	u := map[interface{}]*error{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*error{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice ErrorSlicePtrs) FilterBy(predicate func(*error) bool) ErrorSlicePtrs {
	out := []*error{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice ErrorSlicePtrs) Contains(t *error) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice ErrorSlicePtrs) FilterNotNil() ErrorSlicePtrs {
	return slice.FilterBy(func(t *error) bool {
		return t != nil
	})
}

func (slice ErrorSlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice ErrorSlicePtrs) SameAs(other ErrorSlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*error]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type Float32Slice []float32
type Float32SlicePtrs []*float32

var (
	_ uuid2.UUID
)

func (slice Float32Slice) UniqueBy(keyer func(float32) interface{}) Float32Slice {
	u := map[interface{}]float32{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []float32{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Float32Slice) FilterBy(predicate func(float32) bool) Float32Slice {
	out := []float32{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Float32Slice) Contains(t float32) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Float32Slice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Float32Slice) SameAs(other Float32Slice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[float32]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice Float32SlicePtrs) UniqueBy(keyer func(*float32) interface{}) Float32SlicePtrs {
	u := map[interface{}]*float32{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*float32{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Float32SlicePtrs) FilterBy(predicate func(*float32) bool) Float32SlicePtrs {
	out := []*float32{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Float32SlicePtrs) Contains(t *float32) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Float32SlicePtrs) FilterNotNil() Float32SlicePtrs {
	return slice.FilterBy(func(t *float32) bool {
		return t != nil
	})
}

func (slice Float32SlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Float32SlicePtrs) SameAs(other Float32SlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*float32]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type Float64Slice []float64
type Float64SlicePtrs []*float64

var (
	_ uuid2.UUID
)

func (slice Float64Slice) UniqueBy(keyer func(float64) interface{}) Float64Slice {
	u := map[interface{}]float64{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []float64{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Float64Slice) FilterBy(predicate func(float64) bool) Float64Slice {
	out := []float64{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Float64Slice) Contains(t float64) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Float64Slice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Float64Slice) SameAs(other Float64Slice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[float64]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice Float64SlicePtrs) UniqueBy(keyer func(*float64) interface{}) Float64SlicePtrs {
	u := map[interface{}]*float64{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*float64{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Float64SlicePtrs) FilterBy(predicate func(*float64) bool) Float64SlicePtrs {
	out := []*float64{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Float64SlicePtrs) Contains(t *float64) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Float64SlicePtrs) FilterNotNil() Float64SlicePtrs {
	return slice.FilterBy(func(t *float64) bool {
		return t != nil
	})
}

func (slice Float64SlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Float64SlicePtrs) SameAs(other Float64SlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*float64]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type IntSlice []int
type IntSlicePtrs []*int

var (
	_ uuid2.UUID
)

func (slice IntSlice) UniqueBy(keyer func(int) interface{}) IntSlice {
	u := map[interface{}]int{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []int{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice IntSlice) FilterBy(predicate func(int) bool) IntSlice {
	out := []int{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice IntSlice) Contains(t int) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice IntSlice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice IntSlice) SameAs(other IntSlice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[int]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice IntSlicePtrs) UniqueBy(keyer func(*int) interface{}) IntSlicePtrs {
	u := map[interface{}]*int{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*int{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice IntSlicePtrs) FilterBy(predicate func(*int) bool) IntSlicePtrs {
	out := []*int{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice IntSlicePtrs) Contains(t *int) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice IntSlicePtrs) FilterNotNil() IntSlicePtrs {
	return slice.FilterBy(func(t *int) bool {
		return t != nil
	})
}

func (slice IntSlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice IntSlicePtrs) SameAs(other IntSlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*int]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type Int16Slice []int16
type Int16SlicePtrs []*int16

var (
	_ uuid2.UUID
)

func (slice Int16Slice) UniqueBy(keyer func(int16) interface{}) Int16Slice {
	u := map[interface{}]int16{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []int16{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Int16Slice) FilterBy(predicate func(int16) bool) Int16Slice {
	out := []int16{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Int16Slice) Contains(t int16) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Int16Slice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Int16Slice) SameAs(other Int16Slice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[int16]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice Int16SlicePtrs) UniqueBy(keyer func(*int16) interface{}) Int16SlicePtrs {
	u := map[interface{}]*int16{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*int16{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Int16SlicePtrs) FilterBy(predicate func(*int16) bool) Int16SlicePtrs {
	out := []*int16{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Int16SlicePtrs) Contains(t *int16) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Int16SlicePtrs) FilterNotNil() Int16SlicePtrs {
	return slice.FilterBy(func(t *int16) bool {
		return t != nil
	})
}

func (slice Int16SlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Int16SlicePtrs) SameAs(other Int16SlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*int16]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type Int32Slice []int32
type Int32SlicePtrs []*int32

var (
	_ uuid2.UUID
)

func (slice Int32Slice) UniqueBy(keyer func(int32) interface{}) Int32Slice {
	u := map[interface{}]int32{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []int32{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Int32Slice) FilterBy(predicate func(int32) bool) Int32Slice {
	out := []int32{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Int32Slice) Contains(t int32) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Int32Slice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Int32Slice) SameAs(other Int32Slice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[int32]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice Int32SlicePtrs) UniqueBy(keyer func(*int32) interface{}) Int32SlicePtrs {
	u := map[interface{}]*int32{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*int32{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Int32SlicePtrs) FilterBy(predicate func(*int32) bool) Int32SlicePtrs {
	out := []*int32{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Int32SlicePtrs) Contains(t *int32) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Int32SlicePtrs) FilterNotNil() Int32SlicePtrs {
	return slice.FilterBy(func(t *int32) bool {
		return t != nil
	})
}

func (slice Int32SlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Int32SlicePtrs) SameAs(other Int32SlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*int32]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type Int64Slice []int64
type Int64SlicePtrs []*int64

var (
	_ uuid2.UUID
)

func (slice Int64Slice) UniqueBy(keyer func(int64) interface{}) Int64Slice {
	u := map[interface{}]int64{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []int64{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Int64Slice) FilterBy(predicate func(int64) bool) Int64Slice {
	out := []int64{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Int64Slice) Contains(t int64) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Int64Slice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Int64Slice) SameAs(other Int64Slice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[int64]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice Int64SlicePtrs) UniqueBy(keyer func(*int64) interface{}) Int64SlicePtrs {
	u := map[interface{}]*int64{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*int64{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Int64SlicePtrs) FilterBy(predicate func(*int64) bool) Int64SlicePtrs {
	out := []*int64{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Int64SlicePtrs) Contains(t *int64) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Int64SlicePtrs) FilterNotNil() Int64SlicePtrs {
	return slice.FilterBy(func(t *int64) bool {
		return t != nil
	})
}

func (slice Int64SlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Int64SlicePtrs) SameAs(other Int64SlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*int64]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type Int8Slice []int8
type Int8SlicePtrs []*int8

var (
	_ uuid2.UUID
)

func (slice Int8Slice) UniqueBy(keyer func(int8) interface{}) Int8Slice {
	u := map[interface{}]int8{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []int8{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Int8Slice) FilterBy(predicate func(int8) bool) Int8Slice {
	out := []int8{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Int8Slice) Contains(t int8) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Int8Slice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Int8Slice) SameAs(other Int8Slice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[int8]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice Int8SlicePtrs) UniqueBy(keyer func(*int8) interface{}) Int8SlicePtrs {
	u := map[interface{}]*int8{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*int8{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Int8SlicePtrs) FilterBy(predicate func(*int8) bool) Int8SlicePtrs {
	out := []*int8{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Int8SlicePtrs) Contains(t *int8) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Int8SlicePtrs) FilterNotNil() Int8SlicePtrs {
	return slice.FilterBy(func(t *int8) bool {
		return t != nil
	})
}

func (slice Int8SlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Int8SlicePtrs) SameAs(other Int8SlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*int8]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type RuneSlice []rune
type RuneSlicePtrs []*rune

var (
	_ uuid2.UUID
)

func (slice RuneSlice) UniqueBy(keyer func(rune) interface{}) RuneSlice {
	u := map[interface{}]rune{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []rune{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice RuneSlice) FilterBy(predicate func(rune) bool) RuneSlice {
	out := []rune{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice RuneSlice) Contains(t rune) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice RuneSlice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice RuneSlice) SameAs(other RuneSlice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[rune]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice RuneSlicePtrs) UniqueBy(keyer func(*rune) interface{}) RuneSlicePtrs {
	u := map[interface{}]*rune{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*rune{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice RuneSlicePtrs) FilterBy(predicate func(*rune) bool) RuneSlicePtrs {
	out := []*rune{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice RuneSlicePtrs) Contains(t *rune) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice RuneSlicePtrs) FilterNotNil() RuneSlicePtrs {
	return slice.FilterBy(func(t *rune) bool {
		return t != nil
	})
}

func (slice RuneSlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice RuneSlicePtrs) SameAs(other RuneSlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*rune]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type StringSlice []string
type StringSlicePtrs []*string

var (
	_ uuid2.UUID
)

func (slice StringSlice) UniqueBy(keyer func(string) interface{}) StringSlice {
	u := map[interface{}]string{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []string{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice StringSlice) FilterBy(predicate func(string) bool) StringSlice {
	out := []string{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice StringSlice) Contains(t string) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice StringSlice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice StringSlice) SameAs(other StringSlice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[string]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice StringSlicePtrs) UniqueBy(keyer func(*string) interface{}) StringSlicePtrs {
	u := map[interface{}]*string{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*string{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice StringSlicePtrs) FilterBy(predicate func(*string) bool) StringSlicePtrs {
	out := []*string{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice StringSlicePtrs) Contains(t *string) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice StringSlicePtrs) FilterNotNil() StringSlicePtrs {
	return slice.FilterBy(func(t *string) bool {
		return t != nil
	})
}

func (slice StringSlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice StringSlicePtrs) SameAs(other StringSlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*string]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type UintSlice []uint
type UintSlicePtrs []*uint

var (
	_ uuid2.UUID
)

func (slice UintSlice) UniqueBy(keyer func(uint) interface{}) UintSlice {
	u := map[interface{}]uint{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []uint{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice UintSlice) FilterBy(predicate func(uint) bool) UintSlice {
	out := []uint{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice UintSlice) Contains(t uint) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice UintSlice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice UintSlice) SameAs(other UintSlice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[uint]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice UintSlicePtrs) UniqueBy(keyer func(*uint) interface{}) UintSlicePtrs {
	u := map[interface{}]*uint{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*uint{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice UintSlicePtrs) FilterBy(predicate func(*uint) bool) UintSlicePtrs {
	out := []*uint{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice UintSlicePtrs) Contains(t *uint) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice UintSlicePtrs) FilterNotNil() UintSlicePtrs {
	return slice.FilterBy(func(t *uint) bool {
		return t != nil
	})
}

func (slice UintSlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice UintSlicePtrs) SameAs(other UintSlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*uint]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type Uint16Slice []uint16
type Uint16SlicePtrs []*uint16

var (
	_ uuid2.UUID
)

func (slice Uint16Slice) UniqueBy(keyer func(uint16) interface{}) Uint16Slice {
	u := map[interface{}]uint16{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []uint16{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Uint16Slice) FilterBy(predicate func(uint16) bool) Uint16Slice {
	out := []uint16{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Uint16Slice) Contains(t uint16) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Uint16Slice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Uint16Slice) SameAs(other Uint16Slice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[uint16]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice Uint16SlicePtrs) UniqueBy(keyer func(*uint16) interface{}) Uint16SlicePtrs {
	u := map[interface{}]*uint16{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*uint16{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Uint16SlicePtrs) FilterBy(predicate func(*uint16) bool) Uint16SlicePtrs {
	out := []*uint16{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Uint16SlicePtrs) Contains(t *uint16) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Uint16SlicePtrs) FilterNotNil() Uint16SlicePtrs {
	return slice.FilterBy(func(t *uint16) bool {
		return t != nil
	})
}

func (slice Uint16SlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Uint16SlicePtrs) SameAs(other Uint16SlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*uint16]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type Uint32Slice []uint32
type Uint32SlicePtrs []*uint32

var (
	_ uuid2.UUID
)

func (slice Uint32Slice) UniqueBy(keyer func(uint32) interface{}) Uint32Slice {
	u := map[interface{}]uint32{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []uint32{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Uint32Slice) FilterBy(predicate func(uint32) bool) Uint32Slice {
	out := []uint32{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Uint32Slice) Contains(t uint32) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Uint32Slice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Uint32Slice) SameAs(other Uint32Slice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[uint32]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice Uint32SlicePtrs) UniqueBy(keyer func(*uint32) interface{}) Uint32SlicePtrs {
	u := map[interface{}]*uint32{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*uint32{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Uint32SlicePtrs) FilterBy(predicate func(*uint32) bool) Uint32SlicePtrs {
	out := []*uint32{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Uint32SlicePtrs) Contains(t *uint32) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Uint32SlicePtrs) FilterNotNil() Uint32SlicePtrs {
	return slice.FilterBy(func(t *uint32) bool {
		return t != nil
	})
}

func (slice Uint32SlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Uint32SlicePtrs) SameAs(other Uint32SlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*uint32]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type Uint64Slice []uint64
type Uint64SlicePtrs []*uint64

var (
	_ uuid2.UUID
)

func (slice Uint64Slice) UniqueBy(keyer func(uint64) interface{}) Uint64Slice {
	u := map[interface{}]uint64{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []uint64{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Uint64Slice) FilterBy(predicate func(uint64) bool) Uint64Slice {
	out := []uint64{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Uint64Slice) Contains(t uint64) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Uint64Slice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Uint64Slice) SameAs(other Uint64Slice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[uint64]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice Uint64SlicePtrs) UniqueBy(keyer func(*uint64) interface{}) Uint64SlicePtrs {
	u := map[interface{}]*uint64{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*uint64{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Uint64SlicePtrs) FilterBy(predicate func(*uint64) bool) Uint64SlicePtrs {
	out := []*uint64{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Uint64SlicePtrs) Contains(t *uint64) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Uint64SlicePtrs) FilterNotNil() Uint64SlicePtrs {
	return slice.FilterBy(func(t *uint64) bool {
		return t != nil
	})
}

func (slice Uint64SlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Uint64SlicePtrs) SameAs(other Uint64SlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*uint64]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type Uint8Slice []uint8
type Uint8SlicePtrs []*uint8

var (
	_ uuid2.UUID
)

func (slice Uint8Slice) UniqueBy(keyer func(uint8) interface{}) Uint8Slice {
	u := map[interface{}]uint8{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []uint8{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Uint8Slice) FilterBy(predicate func(uint8) bool) Uint8Slice {
	out := []uint8{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Uint8Slice) Contains(t uint8) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Uint8Slice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Uint8Slice) SameAs(other Uint8Slice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[uint8]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice Uint8SlicePtrs) UniqueBy(keyer func(*uint8) interface{}) Uint8SlicePtrs {
	u := map[interface{}]*uint8{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*uint8{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Uint8SlicePtrs) FilterBy(predicate func(*uint8) bool) Uint8SlicePtrs {
	out := []*uint8{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Uint8SlicePtrs) Contains(t *uint8) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Uint8SlicePtrs) FilterNotNil() Uint8SlicePtrs {
	return slice.FilterBy(func(t *uint8) bool {
		return t != nil
	})
}

func (slice Uint8SlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Uint8SlicePtrs) SameAs(other Uint8SlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*uint8]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type UintptrSlice []uintptr
type UintptrSlicePtrs []*uintptr

var (
	_ uuid2.UUID
)

func (slice UintptrSlice) UniqueBy(keyer func(uintptr) interface{}) UintptrSlice {
	u := map[interface{}]uintptr{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []uintptr{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice UintptrSlice) FilterBy(predicate func(uintptr) bool) UintptrSlice {
	out := []uintptr{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice UintptrSlice) Contains(t uintptr) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice UintptrSlice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice UintptrSlice) SameAs(other UintptrSlice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[uintptr]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice UintptrSlicePtrs) UniqueBy(keyer func(*uintptr) interface{}) UintptrSlicePtrs {
	u := map[interface{}]*uintptr{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*uintptr{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice UintptrSlicePtrs) FilterBy(predicate func(*uintptr) bool) UintptrSlicePtrs {
	out := []*uintptr{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice UintptrSlicePtrs) Contains(t *uintptr) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice UintptrSlicePtrs) FilterNotNil() UintptrSlicePtrs {
	return slice.FilterBy(func(t *uintptr) bool {
		return t != nil
	})
}

func (slice UintptrSlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice UintptrSlicePtrs) SameAs(other UintptrSlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*uintptr]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

type Uuid2UUIDSlice []uuid2.UUID
type Uuid2UUIDSlicePtrs []*uuid2.UUID

var (
	_ uuid2.UUID
)

func (slice Uuid2UUIDSlice) UniqueBy(keyer func(uuid2.UUID) interface{}) Uuid2UUIDSlice {
	u := map[interface{}]uuid2.UUID{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []uuid2.UUID{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Uuid2UUIDSlice) FilterBy(predicate func(uuid2.UUID) bool) Uuid2UUIDSlice {
	out := []uuid2.UUID{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Uuid2UUIDSlice) Contains(t uuid2.UUID) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Uuid2UUIDSlice) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Uuid2UUIDSlice) SameAs(other Uuid2UUIDSlice) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[uuid2.UUID]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}

//
// Slice of pointers
//

func (slice Uuid2UUIDSlicePtrs) UniqueBy(keyer func(*uuid2.UUID) interface{}) Uuid2UUIDSlicePtrs {
	u := map[interface{}]*uuid2.UUID{}

	for _, item := range slice {
		key := keyer(item)
		u[key] = item
	}

	out := []*uuid2.UUID{}
	for _, item := range u {
		out = append(out, item)
	}
	return out
}

func (slice Uuid2UUIDSlicePtrs) FilterBy(predicate func(*uuid2.UUID) bool) Uuid2UUIDSlicePtrs {
	out := []*uuid2.UUID{}
	for _, item := range slice {
		if predicate(item) {
			out = append(out, item)
		}
	}

	return out
}

func (slice Uuid2UUIDSlicePtrs) Contains(t *uuid2.UUID) bool {
	for _, item := range slice {
		if item == t {
			return true
		}
	}

	return false
}

func (slice Uuid2UUIDSlicePtrs) FilterNotNil() Uuid2UUIDSlicePtrs {
	return slice.FilterBy(func(t *uuid2.UUID) bool {
		return t != nil
	})
}

func (slice Uuid2UUIDSlicePtrs) IsEmpty() bool {
	return len(slice) == 0
}

// from https://stackoverflow.com/a/36000696
func (slice Uuid2UUIDSlicePtrs) SameAs(other Uuid2UUIDSlicePtrs) bool {
	if len(slice) != len(other) {
		return false
	}
	// create a map of string -> int
	diff := make(map[*uuid2.UUID]int, len(slice))
	for _, _x := range slice {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}

	for _, _y := range other {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}

	return len(diff) == 0
}
